
phaseOne_v4.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
   0:	33 c0       	rjmp	.+102    	; 0x68 <__ctors_end>
   2:	00 00       	nop
   4:	4c c0       	rjmp	.+152    	; 0x9e <__bad_interrupt>
   6:	00 00       	nop
   8:	4a c0       	rjmp	.+148    	; 0x9e <__bad_interrupt>
   a:	00 00       	nop
   c:	48 c0       	rjmp	.+144    	; 0x9e <__bad_interrupt>
   e:	00 00       	nop
  10:	46 c0       	rjmp	.+140    	; 0x9e <__bad_interrupt>
  12:	00 00       	nop
  14:	44 c0       	rjmp	.+136    	; 0x9e <__bad_interrupt>
  16:	00 00       	nop
  18:	42 c0       	rjmp	.+132    	; 0x9e <__bad_interrupt>
  1a:	00 00       	nop
  1c:	40 c0       	rjmp	.+128    	; 0x9e <__bad_interrupt>
  1e:	00 00       	nop
  20:	3e c0       	rjmp	.+124    	; 0x9e <__bad_interrupt>
  22:	00 00       	nop
  24:	3c c0       	rjmp	.+120    	; 0x9e <__bad_interrupt>
  26:	00 00       	nop
  28:	3a c0       	rjmp	.+116    	; 0x9e <__bad_interrupt>
  2a:	00 00       	nop
  2c:	38 c0       	rjmp	.+112    	; 0x9e <__bad_interrupt>
  2e:	00 00       	nop
  30:	36 c0       	rjmp	.+108    	; 0x9e <__bad_interrupt>
  32:	00 00       	nop
  34:	34 c0       	rjmp	.+104    	; 0x9e <__bad_interrupt>
  36:	00 00       	nop
  38:	32 c0       	rjmp	.+100    	; 0x9e <__bad_interrupt>
  3a:	00 00       	nop
  3c:	30 c0       	rjmp	.+96     	; 0x9e <__bad_interrupt>
  3e:	00 00       	nop
  40:	2e c0       	rjmp	.+92     	; 0x9e <__bad_interrupt>
  42:	00 00       	nop
  44:	2c c0       	rjmp	.+88     	; 0x9e <__bad_interrupt>
  46:	00 00       	nop
  48:	2a c0       	rjmp	.+84     	; 0x9e <__bad_interrupt>
  4a:	00 00       	nop
  4c:	28 c0       	rjmp	.+80     	; 0x9e <__bad_interrupt>
  4e:	00 00       	nop
  50:	26 c0       	rjmp	.+76     	; 0x9e <__bad_interrupt>
  52:	00 00       	nop
  54:	24 c0       	rjmp	.+72     	; 0x9e <__bad_interrupt>
  56:	00 00       	nop
  58:	22 c0       	rjmp	.+68     	; 0x9e <__bad_interrupt>
  5a:	00 00       	nop
  5c:	20 c0       	rjmp	.+64     	; 0x9e <__bad_interrupt>
  5e:	00 00       	nop
  60:	1e c0       	rjmp	.+60     	; 0x9e <__bad_interrupt>
  62:	00 00       	nop
  64:	1c c0       	rjmp	.+56     	; 0x9e <__bad_interrupt>
	...

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e8 e6       	ldi	r30, 0x68	; 104
  7c:	f5 e0       	ldi	r31, 0x05	; 5
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	aa 33       	cpi	r26, 0x3A	; 58
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	11 e0       	ldi	r17, 0x01	; 1
  8c:	aa e3       	ldi	r26, 0x3A	; 58
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	ad 34       	cpi	r26, 0x4D	; 77
  96:	b1 07       	cpc	r27, r17
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	6f d0       	rcall	.+222    	; 0x17a <main>
  9c:	63 c2       	rjmp	.+1222   	; 0x564 <_exit>

0000009e <__bad_interrupt>:
  9e:	b0 cf       	rjmp	.-160    	; 0x0 <__vectors>

000000a0 <emergencyBrake>:
// ------------------------------------------------------------------

void emergencyBrake(void)
{  

 if(leftInfraReading > 950 || rightInfraReading > 950)
  a0:	80 91 4b 01 	lds	r24, 0x014B
  a4:	90 91 4c 01 	lds	r25, 0x014C
  a8:	87 3b       	cpi	r24, 0xB7	; 183
  aa:	93 40       	sbci	r25, 0x03	; 3
  ac:	38 f4       	brcc	.+14     	; 0xbc <emergencyBrake+0x1c>
  ae:	80 91 49 01 	lds	r24, 0x0149
  b2:	90 91 4a 01 	lds	r25, 0x014A
  b6:	87 3b       	cpi	r24, 0xB7	; 183
  b8:	93 40       	sbci	r25, 0x03	; 3
  ba:	88 f1       	brcs	.+98     	; 0x11e <emergencyBrake+0x7e>
 { 
       drive(BACKWARD, 150, 150);
  bc:	46 e9       	ldi	r20, 0x96	; 150
  be:	66 e9       	ldi	r22, 0x96	; 150
  c0:	82 e0       	ldi	r24, 0x02	; 2
  c2:	12 d2       	rcall	.+1060   	; 0x4e8 <drive>
  c4:	8f e5       	ldi	r24, 0x5F	; 95
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  c6:	9a ee       	ldi	r25, 0xEA	; 234
  c8:	20 e0       	ldi	r18, 0x00	; 0
  ca:	81 50       	subi	r24, 0x01	; 1
  cc:	90 40       	sbci	r25, 0x00	; 0
  ce:	20 40       	sbci	r18, 0x00	; 0
  d0:	e1 f7       	brne	.-8      	; 0xca <emergencyBrake+0x2a>
  d2:	00 c0       	rjmp	.+0      	; 0xd4 <emergencyBrake+0x34>
  d4:	00 00       	nop
  d6:	20 91 4b 01 	lds	r18, 0x014B
       _delay_ms(300);
       if (leftInfraReading > rightInfraReading)
  da:	30 91 4c 01 	lds	r19, 0x014C
  de:	80 91 49 01 	lds	r24, 0x0149
  e2:	90 91 4a 01 	lds	r25, 0x014A
  e6:	46 ee       	ldi	r20, 0xE6	; 230
       {
           drive(PIVOT_LEFT, 230, 230);
  e8:	66 ee       	ldi	r22, 0xE6	; 230
  ea:	82 17       	cp	r24, r18

 if(leftInfraReading > 950 || rightInfraReading > 950)
 { 
       drive(BACKWARD, 150, 150);
       _delay_ms(300);
       if (leftInfraReading > rightInfraReading)
  ec:	93 07       	cpc	r25, r19
  ee:	10 f4       	brcc	.+4      	; 0xf4 <emergencyBrake+0x54>
  f0:	85 e0       	ldi	r24, 0x05	; 5
       {
           drive(PIVOT_LEFT, 230, 230);
  f2:	01 c0       	rjmp	.+2      	; 0xf6 <emergencyBrake+0x56>
  f4:	84 e0       	ldi	r24, 0x04	; 4

           _delay_ms(800);
       }
       else
       { 
	  drive(PIVOT_RIGHT, 230, 230); 
  f6:	f8 d1       	rcall	.+1008   	; 0x4e8 <drive>
  f8:	8f ef       	ldi	r24, 0xFF	; 255
  fa:	90 e7       	ldi	r25, 0x70	; 112
  fc:	22 e0       	ldi	r18, 0x02	; 2
  fe:	81 50       	subi	r24, 0x01	; 1
 100:	90 40       	sbci	r25, 0x00	; 0
 102:	20 40       	sbci	r18, 0x00	; 0
 104:	e1 f7       	brne	.-8      	; 0xfe <emergencyBrake+0x5e>
 106:	00 c0       	rjmp	.+0      	; 0x108 <emergencyBrake+0x68>
 108:	00 00       	nop
 10a:	40 e0       	ldi	r20, 0x00	; 0
 10c:	60 e0       	ldi	r22, 0x00	; 0
          _delay_ms(800);
       }
      drive(BRAKE, 0, 0);
 10e:	80 e0       	ldi	r24, 0x00	; 0
 110:	eb d1       	rcall	.+982    	; 0x4e8 <drive>
 112:	87 e8       	ldi	r24, 0x87	; 135
 114:	93 e1       	ldi	r25, 0x13	; 19
 116:	01 97       	sbiw	r24, 0x01	; 1
 118:	f1 f7       	brne	.-4      	; 0x116 <emergencyBrake+0x76>
 11a:	00 c0       	rjmp	.+0      	; 0x11c <emergencyBrake+0x7c>
 11c:	00 00       	nop
 11e:	08 95       	ret

00000120 <sensorDelta>:
	Takes a sensor reading and an expected sensor threshold as inputs
	Returns the absolute value of the difference
	*/
	uint16_t delta = 0;
	
	if(reading > threshold)
 120:	68 17       	cp	r22, r24
 122:	79 07       	cpc	r23, r25
 124:	18 f4       	brcc	.+6      	; 0x12c <sensorDelta+0xc>
	{
		delta = reading - threshold;
 126:	86 1b       	sub	r24, r22
 128:	97 0b       	sbc	r25, r23
 12a:	08 95       	ret
	}
	else if(threshold > reading)
 12c:	86 17       	cp	r24, r22
 12e:	97 07       	cpc	r25, r23
 130:	28 f4       	brcc	.+10     	; 0x13c <sensorDelta+0x1c>
	{
		delta = threshold - reading;
 132:	9b 01       	movw	r18, r22
 134:	28 1b       	sub	r18, r24
 136:	39 0b       	sbc	r19, r25
 138:	c9 01       	movw	r24, r18
 13a:	08 95       	ret
{
	/* 
	Takes a sensor reading and an expected sensor threshold as inputs
	Returns the absolute value of the difference
	*/
	uint16_t delta = 0;
 13c:	80 e0       	ldi	r24, 0x00	; 0
 13e:	90 e0       	ldi	r25, 0x00	; 0
	else if(threshold > reading)
	{
		delta = threshold - reading;
	}
	return delta;
}
 140:	08 95       	ret

00000142 <servoArm>:

void servoArm(uint16_t timeVal)
{
 142:	cf 93       	push	r28
 144:	df 93       	push	r29
 146:	ec 01       	movw	r28, r24
  //Initialize Timer1 for Servo
  initServoOC1A();
 148:	c9 d0       	rcall	.+402    	; 0x2dc <initServoOC1A>
 14a:	87 e8       	ldi	r24, 0x87	; 135
 14c:	93 e1       	ldi	r25, 0x13	; 19
 14e:	01 97       	sbiw	r24, 0x01	; 1
 150:	f1 f7       	brne	.-4      	; 0x14e <servoArm+0xc>
 152:	00 c0       	rjmp	.+0      	; 0x154 <servoArm+0x12>
 154:	00 00       	nop
 156:	21 9a       	sbi	0x04, 1	; 4
  _delay_ms(20);
  //Set PB1 to Output
  DDRB |= (1 << PB1);
 158:	d0 93 89 00 	sts	0x0089, r29
  //Set Duty Cycle
   OCR1A = timeVal;
 15c:	c0 93 88 00 	sts	0x0088, r28
 160:	9f e7       	ldi	r25, 0x7F	; 127
 162:	2a e1       	ldi	r18, 0x1A	; 26
 164:	86 e0       	ldi	r24, 0x06	; 6
 166:	91 50       	subi	r25, 0x01	; 1
 168:	20 40       	sbci	r18, 0x00	; 0
 16a:	80 40       	sbci	r24, 0x00	; 0
 16c:	e1 f7       	brne	.-8      	; 0x166 <servoArm+0x24>
 16e:	00 c0       	rjmp	.+0      	; 0x170 <servoArm+0x2e>
 170:	00 00       	nop
 172:	21 98       	cbi	0x04, 1	; 4
  //Wait Until The Servo Arm Is In Place
  _delay_ms(2000);
  //Set PB1 to Input
 DDRB &= ~(1 << PB1);
 174:	df 91       	pop	r29
  //Re Initialize Timer for UltraSonic Sensors
  initSonicTimer1();
}
 176:	cf 91       	pop	r28
 178:	f3 c0       	rjmp	.+486    	; 0x360 <initSonicTimer1>

0000017a <main>:

int main(void)
{
	
  //Bit Setting --------------------------------------------------
  servoArm(SERVO_POS_ONE);
 17a:	8c ed       	ldi	r24, 0xDC	; 220
 17c:	95 e0       	ldi	r25, 0x05	; 5
 17e:	e1 df       	rcall	.-62     	; 0x142 <servoArm>
 180:	2f e3       	ldi	r18, 0x3F	; 63
 182:	8d e0       	ldi	r24, 0x0D	; 13
 184:	93 e0       	ldi	r25, 0x03	; 3
 186:	21 50       	subi	r18, 0x01	; 1
 188:	80 40       	sbci	r24, 0x00	; 0
 18a:	90 40       	sbci	r25, 0x00	; 0
 18c:	e1 f7       	brne	.-8      	; 0x186 <main+0xc>
 18e:	00 c0       	rjmp	.+0      	; 0x190 <main+0x16>
 190:	00 00       	nop
 192:	bc d0       	rcall	.+376    	; 0x30c <initUSART>
  _delay_ms(1000);
  initUSART();
 194:	e5 d0       	rcall	.+458    	; 0x360 <initSonicTimer1>
 196:	4e d1       	rcall	.+668    	; 0x434 <initInfraADC>
  initSonicTimer1();
 198:	75 d1       	rcall	.+746    	; 0x484 <initMotorAB>
 19a:	86 eb       	ldi	r24, 0xB6	; 182
  initInfraADC();
 19c:	93 e0       	ldi	r25, 0x03	; 3
 19e:	d1 df       	rcall	.-94     	; 0x142 <servoArm>
  initMotorAB();
 1a0:	80 e0       	ldi	r24, 0x00	; 0
 1a2:	56 d1       	rcall	.+684    	; 0x450 <getReading>
  servoArm(SERVO_POS_TWO);
 1a4:	90 93 4c 01 	sts	0x014C, r25
 1a8:	80 93 4b 01 	sts	0x014B, r24
  // -------------------------------------------------------------
	
  while(1)
  {
      // Get sensor data-----------------------------------------
      leftInfraReading = getReading(LEFT_INFRA_CH);
 1ac:	81 e0       	ldi	r24, 0x01	; 1
 1ae:	50 d1       	rcall	.+672    	; 0x450 <getReading>
 1b0:	90 93 4a 01 	sts	0x014A, r25
 1b4:	80 93 49 01 	sts	0x0149, r24
 1b8:	e1 d0       	rcall	.+450    	; 0x37c <ultraSonic1>
      rightInfraReading= getReading(RIGHT_INFRA_CH);	
 1ba:	90 93 48 01 	sts	0x0148, r25
 1be:	80 93 47 01 	sts	0x0147, r24
 1c2:	f3 d0       	rcall	.+486    	; 0x3aa <ultraSonic2>
 1c4:	90 93 46 01 	sts	0x0146, r25
      ulSonic=ultraSonic1();
 1c8:	80 93 45 01 	sts	0x0145, r24
 1cc:	05 d1       	rcall	.+522    	; 0x3d8 <ultraSonic3>
 1ce:	90 93 44 01 	sts	0x0144, r25
 1d2:	80 93 43 01 	sts	0x0143, r24
      urSonic=ultraSonic2();
 1d6:	17 d1       	rcall	.+558    	; 0x406 <ultraSonic4>
 1d8:	90 93 42 01 	sts	0x0142, r25
 1dc:	80 93 41 01 	sts	0x0141, r24
      llSonic=ultraSonic3();
 1e0:	5f df       	rcall	.-322    	; 0xa0 <emergencyBrake>
 1e2:	cc d0       	rcall	.+408    	; 0x37c <ultraSonic1>
 1e4:	69 e0       	ldi	r22, 0x09	; 9
 1e6:	70 e0       	ldi	r23, 0x00	; 0
 1e8:	9b df       	rcall	.-202    	; 0x120 <sensorDelta>
 1ea:	90 e0       	ldi	r25, 0x00	; 0
      lrSonic=ultraSonic4();
 1ec:	90 93 40 01 	sts	0x0140, r25
 1f0:	80 93 3f 01 	sts	0x013F, r24
 1f4:	da d0       	rcall	.+436    	; 0x3aa <ultraSonic2>
 1f6:	68 e0       	ldi	r22, 0x08	; 8
      
      //Emergency Check
      emergencyBrake();
 1f8:	70 e0       	ldi	r23, 0x00	; 0
 1fa:	92 df       	rcall	.-220    	; 0x120 <sensorDelta>
	
      //Check Delta of Actual vs. Expected Foor Upper Sonics
      leftDelta = sensorDelta(ultraSonic1(), L_EXP_DIST);
 1fc:	90 e0       	ldi	r25, 0x00	; 0
 1fe:	90 93 3e 01 	sts	0x013E, r25
 202:	80 93 3d 01 	sts	0x013D, r24
 206:	20 91 3f 01 	lds	r18, 0x013F
 20a:	30 91 40 01 	lds	r19, 0x0140
 20e:	24 30       	cpi	r18, 0x04	; 4
 210:	31 05       	cpc	r19, r1
      rightDelta = sensorDelta(ultraSonic2(), R_EXP_DIST);
 212:	b0 f4       	brcc	.+44     	; 0x240 <main+0xc6>
 214:	04 97       	sbiw	r24, 0x04	; 4
 216:	50 f4       	brcc	.+20     	; 0x22c <main+0xb2>
 218:	43 df       	rcall	.-378    	; 0xa0 <emergencyBrake>
 21a:	80 e0       	ldi	r24, 0x00	; 0
 21c:	91 e0       	ldi	r25, 0x01	; 1
 21e:	8e d0       	rcall	.+284    	; 0x33c <printString>
 220:	48 e7       	ldi	r20, 0x78	; 120
 222:	68 e7       	ldi	r22, 0x78	; 120
 224:	81 e0       	ldi	r24, 0x01	; 1
 226:	60 d1       	rcall	.+704    	; 0x4e8 <drive>
		
		
      // Main conditionals  --------------------------------------
      if((leftDelta < 4) && (rightDelta < 4))
 228:	81 e0       	ldi	r24, 0x01	; 1
 22a:	25 c0       	rjmp	.+74     	; 0x276 <main+0xfc>
 22c:	39 df       	rcall	.-398    	; 0xa0 <emergencyBrake>
 22e:	8e e0       	ldi	r24, 0x0E	; 14
 230:	91 e0       	ldi	r25, 0x01	; 1
 232:	84 d0       	rcall	.+264    	; 0x33c <printString>
 234:	44 eb       	ldi	r20, 0xB4	; 180
 236:	64 eb       	ldi	r22, 0xB4	; 180
 238:	85 e0       	ldi	r24, 0x05	; 5
      {
        emergencyBrake();
 23a:	56 d1       	rcall	.+684    	; 0x4e8 <drive>
 23c:	85 e0       	ldi	r24, 0x05	; 5
	printString("Go straight\n\r");
 23e:	1b c0       	rjmp	.+54     	; 0x276 <main+0xfc>
 240:	04 97       	sbiw	r24, 0x04	; 4
 242:	50 f4       	brcc	.+20     	; 0x258 <main+0xde>
 244:	2d df       	rcall	.-422    	; 0xa0 <emergencyBrake>
	drive(FORWARD, 120, 120);
 246:	88 e1       	ldi	r24, 0x18	; 24
 248:	91 e0       	ldi	r25, 0x01	; 1
 24a:	78 d0       	rcall	.+240    	; 0x33c <printString>
 24c:	48 ec       	ldi	r20, 0xC8	; 200
 24e:	68 ec       	ldi	r22, 0xC8	; 200
	thisTurn = FORWARD;
 250:	84 e0       	ldi	r24, 0x04	; 4
 252:	4a d1       	rcall	.+660    	; 0x4e8 <drive>
      }
      else if(leftDelta < 4)
      {
	emergencyBrake();
 254:	84 e0       	ldi	r24, 0x04	; 4
 256:	0f c0       	rjmp	.+30     	; 0x276 <main+0xfc>
	printString("Go left\n\r");
 258:	23 df       	rcall	.-442    	; 0xa0 <emergencyBrake>
 25a:	44 e6       	ldi	r20, 0x64	; 100
 25c:	6c e8       	ldi	r22, 0x8C	; 140
 25e:	82 e0       	ldi	r24, 0x02	; 2
	drive(PIVOT_LEFT,180,180);
 260:	43 d1       	rcall	.+646    	; 0x4e8 <drive>
 262:	83 ed       	ldi	r24, 0xD3	; 211
 264:	90 e3       	ldi	r25, 0x30	; 48
 266:	01 97       	sbiw	r24, 0x01	; 1
 268:	f1 f7       	brne	.-4      	; 0x266 <main+0xec>
	thisTurn = PIVOT_LEFT;
 26a:	00 c0       	rjmp	.+0      	; 0x26c <main+0xf2>
 26c:	00 00       	nop
      }
      else if(rightDelta < 4)
 26e:	83 e2       	ldi	r24, 0x23	; 35
 270:	91 e0       	ldi	r25, 0x01	; 1
      {
        emergencyBrake();
 272:	64 d0       	rcall	.+200    	; 0x33c <printString>
 274:	82 e0       	ldi	r24, 0x02	; 2
	printString("Go right\n\r");
 276:	80 93 3c 01 	sts	0x013C, r24
 27a:	90 91 3c 01 	lds	r25, 0x013C
	drive(PIVOT_RIGHT,200,200);
 27e:	80 91 3b 01 	lds	r24, 0x013B
 282:	98 13       	cpse	r25, r24
 284:	02 c0       	rjmp	.+4      	; 0x28a <main+0x110>
 286:	92 30       	cpi	r25, 0x02	; 2
	thisTurn = PIVOT_RIGHT;
 288:	e1 f4       	brne	.+56     	; 0x2c2 <main+0x148>
 28a:	80 91 3a 01 	lds	r24, 0x013A
      }
      else
      {
	emergencyBrake();
 28e:	82 30       	cpi	r24, 0x02	; 2
 290:	91 f4       	brne	.+36     	; 0x2b6 <main+0x13c>
 292:	92 30       	cpi	r25, 0x02	; 2
 294:	91 f4       	brne	.+36     	; 0x2ba <main+0x140>
 296:	48 ec       	ldi	r20, 0xC8	; 200
 298:	68 ec       	ldi	r22, 0xC8	; 200
 29a:	84 e0       	ldi	r24, 0x04	; 4
 29c:	25 d1       	rcall	.+586    	; 0x4e8 <drive>
 29e:	10 92 3a 01 	sts	0x013A, r1
 2a2:	9f e5       	ldi	r25, 0x5F	; 95
 2a4:	2a ee       	ldi	r18, 0xEA	; 234
	drive(BACKWARD, 140, 100);
	_delay_ms(50);
	printString("Brake-Backward-Pivot\n\r");
 2a6:	80 e0       	ldi	r24, 0x00	; 0
 2a8:	91 50       	subi	r25, 0x01	; 1
 2aa:	20 40       	sbci	r18, 0x00	; 0
 2ac:	80 40       	sbci	r24, 0x00	; 0
	thisTurn = BACKWARD;
 2ae:	e1 f7       	brne	.-8      	; 0x2a8 <main+0x12e>
 2b0:	00 c0       	rjmp	.+0      	; 0x2b2 <main+0x138>
 2b2:	00 00       	nop
      }
		
      //Corner escape --------------------------------------------
      if((thisTurn != lastTurn) || (thisTurn==BACKWARD))
 2b4:	08 c0       	rjmp	.+16     	; 0x2c6 <main+0x14c>
 2b6:	84 30       	cpi	r24, 0x04	; 4
 2b8:	71 f3       	breq	.-36     	; 0x296 <main+0x11c>
 2ba:	8f 5f       	subi	r24, 0xFF	; 255
 2bc:	80 93 3a 01 	sts	0x013A, r24
 2c0:	02 c0       	rjmp	.+4      	; 0x2c6 <main+0x14c>
 2c2:	10 92 3a 01 	sts	0x013A, r1
      {
	if((cornerCount ==2) && (thisTurn == BACKWARD))
 2c6:	80 91 3c 01 	lds	r24, 0x013C
 2ca:	80 93 3b 01 	sts	0x013B, r24
 2ce:	87 ea       	ldi	r24, 0xA7	; 167
	{
	  drive(PIVOT_RIGHT, 200,200);
 2d0:	91 e6       	ldi	r25, 0x61	; 97
 2d2:	01 97       	sbiw	r24, 0x01	; 1
 2d4:	f1 f7       	brne	.-4      	; 0x2d2 <main+0x158>
 2d6:	00 c0       	rjmp	.+0      	; 0x2d8 <main+0x15e>
 2d8:	00 00       	nop
 2da:	62 cf       	rjmp	.-316    	; 0x1a0 <main+0x26>

000002dc <initServoOC1A>:

void initServoOC1A(void)
{
	//Set Bits in Timer/Counter Control Register Register for Mode 14	
	
	TCCR1A |= (1 << WGM11);
 2dc:	e0 e8       	ldi	r30, 0x80	; 128
 2de:	f0 e0       	ldi	r31, 0x00	; 0
 2e0:	80 81       	ld	r24, Z
 2e2:	82 60       	ori	r24, 0x02	; 2
 2e4:	80 83       	st	Z, r24
	TCCR1B |= (1 << WGM12) | (1 << WGM13);
 2e6:	a1 e8       	ldi	r26, 0x81	; 129
 2e8:	b0 e0       	ldi	r27, 0x00	; 0
 2ea:	8c 91       	ld	r24, X
 2ec:	88 61       	ori	r24, 0x18	; 24
 2ee:	8c 93       	st	X, r24
	
	//Prescale Clock with 1, assuming 1Mghz Clock Speed
	TCCR1B |= (1 << CS10);
 2f0:	8c 91       	ld	r24, X
 2f2:	81 60       	ori	r24, 0x01	; 1
 2f4:	8c 93       	st	X, r24
	
	//Frequency Set with ICR1 value
	//Duty Cycle Set with OCR1A value in main
	//Non-inverting Mode
	ICR1 = 20000;
 2f6:	80 e2       	ldi	r24, 0x20	; 32
 2f8:	9e e4       	ldi	r25, 0x4E	; 78
 2fa:	90 93 87 00 	sts	0x0087, r25
 2fe:	80 93 86 00 	sts	0x0086, r24
	TCCR1A |= (1 << COM1A1);
 302:	80 81       	ld	r24, Z
 304:	80 68       	ori	r24, 0x80	; 128
 306:	80 83       	st	Z, r24
	//Disable Output on PB1 / OC1A
	DDRB &= ~(1 << PB1);
 308:	21 98       	cbi	0x04, 1	; 4
 30a:	08 95       	ret

0000030c <initUSART>:
#include <avr/io.h>
#include "USART.h"
#include <util/setbaud.h>

void initUSART(void) {                                /* requires BAUD */
  UBRR0H = UBRRH_VALUE;                        /* defined in setbaud.h */
 30c:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = UBRRL_VALUE;
 310:	8c e0       	ldi	r24, 0x0C	; 12
 312:	80 93 c4 00 	sts	0x00C4, r24
#if USE_2X
  UCSR0A |= (1 << U2X0);
 316:	e0 ec       	ldi	r30, 0xC0	; 192
 318:	f0 e0       	ldi	r31, 0x00	; 0
 31a:	80 81       	ld	r24, Z
 31c:	82 60       	ori	r24, 0x02	; 2
 31e:	80 83       	st	Z, r24
#else
  UCSR0A &= ~(1 << U2X0);
#endif
                                  /* Enable USART transmitter/receiver */
  UCSR0B = (1 << TXEN0) | (1 << RXEN0);
 320:	88 e1       	ldi	r24, 0x18	; 24
 322:	80 93 c1 00 	sts	0x00C1, r24
  UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);   /* 8 data bits, 1 stop bit */
 326:	86 e0       	ldi	r24, 0x06	; 6
 328:	80 93 c2 00 	sts	0x00C2, r24
 32c:	08 95       	ret

0000032e <transmitByte>:
}


void transmitByte(uint8_t data) {
                                     /* Wait for empty transmit buffer */
  loop_until_bit_is_set(UCSR0A, UDRE0);
 32e:	90 91 c0 00 	lds	r25, 0x00C0
 332:	95 ff       	sbrs	r25, 5
 334:	fc cf       	rjmp	.-8      	; 0x32e <transmitByte>
  UDR0 = data;                                            /* send data */
 336:	80 93 c6 00 	sts	0x00C6, r24
 33a:	08 95       	ret

0000033c <printString>:
}


                       /* Here are a bunch of useful printing commands */

void printString(const char myString[]) {
 33c:	1f 93       	push	r17
 33e:	cf 93       	push	r28
 340:	df 93       	push	r29
 342:	ec 01       	movw	r28, r24
  uint8_t i = 0;
 344:	10 e0       	ldi	r17, 0x00	; 0
  while (myString[i]) {
 346:	fe 01       	movw	r30, r28
 348:	e1 0f       	add	r30, r17
 34a:	f1 1d       	adc	r31, r1
 34c:	80 81       	ld	r24, Z
 34e:	88 23       	and	r24, r24
 350:	19 f0       	breq	.+6      	; 0x358 <printString+0x1c>
    transmitByte(myString[i]);
 352:	ed df       	rcall	.-38     	; 0x32e <transmitByte>
 354:	1f 5f       	subi	r17, 0xFF	; 255
    i++;
 356:	f7 cf       	rjmp	.-18     	; 0x346 <printString+0xa>
 358:	df 91       	pop	r29
  }
}
 35a:	cf 91       	pop	r28
 35c:	1f 91       	pop	r17
 35e:	08 95       	ret

00000360 <initSonicTimer1>:
void initSonicTimer1(void)
{
  /* 
  Set Data Direction Registers
  */
  TRIG_DDR1 |= (1 << TRIG_PIN1);
 360:	24 9a       	sbi	0x04, 4	; 4
  TRIG_DDR2 |= (1 << TRIG_PIN2);
 362:	25 9a       	sbi	0x04, 5	; 4

  ECHO_DDR1 &= ~(1 << ECHO_PIN1);
 364:	3d 98       	cbi	0x07, 5	; 7
  ECHO_DDR2 &= ~(1 << ECHO_PIN2); 
 366:	3a 98       	cbi	0x07, 2	; 7
 
  TRIG_DDR3 |= (1 << TRIG_PIN3);
 368:	23 9a       	sbi	0x04, 3	; 4
  TRIG_DDR4 |= (1 << TRIG_PIN4);
 36a:	3c 9a       	sbi	0x07, 4	; 7

  ECHO_DDR3 &= ~(1 << ECHO_PIN3);
 36c:	22 98       	cbi	0x04, 2	; 4
  ECHO_DDR4 &= ~(1 << ECHO_PIN4); 
 36e:	3b 98       	cbi	0x07, 3	; 7
  Initate Timer
  */
  //Normal Mode
  //All bits clear in TCCR1A
  //Prescale by 1 - Assumes Clock Speed Runs at 1 Mghz
  TCCR1B |= (1 << CS10);
 370:	e1 e8       	ldi	r30, 0x81	; 129
 372:	f0 e0       	ldi	r31, 0x00	; 0
 374:	80 81       	ld	r24, Z
 376:	81 60       	ori	r24, 0x01	; 1
 378:	80 83       	st	Z, r24
 37a:	08 95       	ret

0000037c <ultraSonic1>:

int ultraSonic1(void)
{
	int distance = 0;
	uint16_t time =0;
	TRIG_PORT1 |= (1 << TRIG_PIN1);
 37c:	2c 9a       	sbi	0x05, 4	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 37e:	83 e0       	ldi	r24, 0x03	; 3
 380:	8a 95       	dec	r24
 382:	f1 f7       	brne	.-4      	; 0x380 <ultraSonic1+0x4>
 384:	00 00       	nop
	_delay_us(10);
	TRIG_PORT1 &= ~(1 << TRIG_PIN1);
 386:	2c 98       	cbi	0x05, 4	; 5
	loop_until_bit_is_set(ECHO_IN1,ECHO_PIN1);
 388:	35 9b       	sbis	0x06, 5	; 6
 38a:	fe cf       	rjmp	.-4      	; 0x388 <ultraSonic1+0xc>
	TCNT1 = 0;
 38c:	10 92 85 00 	sts	0x0085, r1
 390:	10 92 84 00 	sts	0x0084, r1
	loop_until_bit_is_clear(ECHO_IN1, ECHO_PIN1);
 394:	35 99       	sbic	0x06, 5	; 6
 396:	fe cf       	rjmp	.-4      	; 0x394 <ultraSonic1+0x18>
	time = TCNT1;
 398:	80 91 84 00 	lds	r24, 0x0084
 39c:	90 91 85 00 	lds	r25, 0x0085
	distance = time  / 58;
 3a0:	6a e3       	ldi	r22, 0x3A	; 58
 3a2:	70 e0       	ldi	r23, 0x00	; 0
 3a4:	cb d0       	rcall	.+406    	; 0x53c <__udivmodhi4>
 3a6:	cb 01       	movw	r24, r22
 3a8:	08 95       	ret

000003aa <ultraSonic2>:

int ultraSonic2(void)
{
	int distance = 0;
	uint16_t time =0;
	TRIG_PORT2 |= (1 << TRIG_PIN2);
 3aa:	2d 9a       	sbi	0x05, 5	; 5
 3ac:	83 e0       	ldi	r24, 0x03	; 3
 3ae:	8a 95       	dec	r24
 3b0:	f1 f7       	brne	.-4      	; 0x3ae <ultraSonic2+0x4>
 3b2:	00 00       	nop
	_delay_us(10);
	TRIG_PORT2 &= ~(1 << TRIG_PIN2);
 3b4:	2d 98       	cbi	0x05, 5	; 5
	loop_until_bit_is_set(ECHO_IN2,ECHO_PIN2);
 3b6:	32 9b       	sbis	0x06, 2	; 6
 3b8:	fe cf       	rjmp	.-4      	; 0x3b6 <ultraSonic2+0xc>
	TCNT1 = 0;
 3ba:	10 92 85 00 	sts	0x0085, r1
 3be:	10 92 84 00 	sts	0x0084, r1
	loop_until_bit_is_clear(ECHO_IN2, ECHO_PIN2);
 3c2:	32 99       	sbic	0x06, 2	; 6
 3c4:	fe cf       	rjmp	.-4      	; 0x3c2 <ultraSonic2+0x18>
	time = TCNT1;
 3c6:	80 91 84 00 	lds	r24, 0x0084
 3ca:	90 91 85 00 	lds	r25, 0x0085
	distance = time / 58;
 3ce:	6a e3       	ldi	r22, 0x3A	; 58
 3d0:	70 e0       	ldi	r23, 0x00	; 0
 3d2:	b4 d0       	rcall	.+360    	; 0x53c <__udivmodhi4>
 3d4:	cb 01       	movw	r24, r22
 3d6:	08 95       	ret

000003d8 <ultraSonic3>:

int ultraSonic3(void)
{
	int distance = 0;
	uint16_t time =0;
	TRIG_PORT3 |= (1 << TRIG_PIN3);
 3d8:	2b 9a       	sbi	0x05, 3	; 5
 3da:	83 e0       	ldi	r24, 0x03	; 3
 3dc:	8a 95       	dec	r24
 3de:	f1 f7       	brne	.-4      	; 0x3dc <ultraSonic3+0x4>
 3e0:	00 00       	nop
	_delay_us(10);
	TRIG_PORT3 &= ~(1 << TRIG_PIN3);
 3e2:	2b 98       	cbi	0x05, 3	; 5
	loop_until_bit_is_set(ECHO_IN3,ECHO_PIN3);
 3e4:	1a 9b       	sbis	0x03, 2	; 3
 3e6:	fe cf       	rjmp	.-4      	; 0x3e4 <ultraSonic3+0xc>
	TCNT1 = 0;
 3e8:	10 92 85 00 	sts	0x0085, r1
 3ec:	10 92 84 00 	sts	0x0084, r1
	loop_until_bit_is_clear(ECHO_IN3, ECHO_PIN3);
 3f0:	1a 99       	sbic	0x03, 2	; 3
 3f2:	fe cf       	rjmp	.-4      	; 0x3f0 <ultraSonic3+0x18>
	time = TCNT1;
 3f4:	80 91 84 00 	lds	r24, 0x0084
 3f8:	90 91 85 00 	lds	r25, 0x0085
	distance = time / 58;
 3fc:	6a e3       	ldi	r22, 0x3A	; 58
 3fe:	70 e0       	ldi	r23, 0x00	; 0
 400:	9d d0       	rcall	.+314    	; 0x53c <__udivmodhi4>
 402:	cb 01       	movw	r24, r22
 404:	08 95       	ret

00000406 <ultraSonic4>:
}
int ultraSonic4(void)
{
	int distance = 0;
	uint16_t time =0;
	TRIG_PORT4 |= (1 << TRIG_PIN4);
 406:	44 9a       	sbi	0x08, 4	; 8
 408:	83 e0       	ldi	r24, 0x03	; 3
 40a:	8a 95       	dec	r24
 40c:	f1 f7       	brne	.-4      	; 0x40a <ultraSonic4+0x4>
 40e:	00 00       	nop
	_delay_us(10);
	TRIG_PORT4 &= ~(1 << TRIG_PIN4);
 410:	44 98       	cbi	0x08, 4	; 8
	loop_until_bit_is_set(ECHO_IN4,ECHO_PIN4);
 412:	33 9b       	sbis	0x06, 3	; 6
 414:	fe cf       	rjmp	.-4      	; 0x412 <ultraSonic4+0xc>
	TCNT1 = 0;
 416:	10 92 85 00 	sts	0x0085, r1
 41a:	10 92 84 00 	sts	0x0084, r1
	loop_until_bit_is_clear(ECHO_IN4, ECHO_PIN4);
 41e:	33 99       	sbic	0x06, 3	; 6
 420:	fe cf       	rjmp	.-4      	; 0x41e <ultraSonic4+0x18>
	time = TCNT1;
 422:	80 91 84 00 	lds	r24, 0x0084
 426:	90 91 85 00 	lds	r25, 0x0085
	distance = time / 58;
 42a:	6a e3       	ldi	r22, 0x3A	; 58
 42c:	70 e0       	ldi	r23, 0x00	; 0
 42e:	86 d0       	rcall	.+268    	; 0x53c <__udivmodhi4>
 430:	cb 01       	movw	r24, r22
 432:	08 95       	ret

00000434 <initInfraADC>:
#include <avr/io.h>
#include "cInfra.h"

void initInfraADC()
{
	ADMUX |= (1 << REFS0);                  	//Ref AVcc 
 434:	ec e7       	ldi	r30, 0x7C	; 124
 436:	f0 e0       	ldi	r31, 0x00	; 0
 438:	80 81       	ld	r24, Z
 43a:	80 64       	ori	r24, 0x40	; 64
 43c:	80 83       	st	Z, r24
	ADCSRA |= (1 << ADPS1) | (1 << ADPS0);    	//ADC clock prescaler Divide by 8
 43e:	ea e7       	ldi	r30, 0x7A	; 122
 440:	f0 e0       	ldi	r31, 0x00	; 0
 442:	80 81       	ld	r24, Z
 444:	83 60       	ori	r24, 0x03	; 3
 446:	80 83       	st	Z, r24
	ADCSRA |= (1 << ADEN);                      //Enable ADC
 448:	80 81       	ld	r24, Z
 44a:	80 68       	ori	r24, 0x80	; 128
 44c:	80 83       	st	Z, r24
 44e:	08 95       	ret

00000450 <getReading>:
}

uint16_t getReading(uint8_t mux_channel)
{
	ADMUX = (0xf0 & ADMUX) | mux_channel;
 450:	90 91 7c 00 	lds	r25, 0x007C
 454:	90 7f       	andi	r25, 0xF0	; 240
 456:	98 2b       	or	r25, r24
 458:	90 93 7c 00 	sts	0x007C, r25
	ADCSRA |= (1 << ADSC);
 45c:	80 91 7a 00 	lds	r24, 0x007A
 460:	80 64       	ori	r24, 0x40	; 64
 462:	80 93 7a 00 	sts	0x007A, r24
	loop_until_bit_is_clear(ADCSRA, ADSC);
 466:	80 91 7a 00 	lds	r24, 0x007A
 46a:	86 fd       	sbrc	r24, 6
 46c:	fc cf       	rjmp	.-8      	; 0x466 <getReading+0x16>
	return (ADC);
 46e:	80 91 78 00 	lds	r24, 0x0078
 472:	90 91 79 00 	lds	r25, 0x0079
 476:	08 95       	ret

00000478 <directionA.part.0>:
		MOTOR_A_2_PORT &= ~(1 << MOTOR_A_2);
	}
	else if (dir == 3)
	{
		//ONE_B High ONE_A Low
		MOTOR_A_1_PORT &= ~(1 << MOTOR_A_1);
 478:	5f 98       	cbi	0x0b, 7	; 11
		MOTOR_A_2_PORT |= (1 << MOTOR_A_2);
 47a:	28 9a       	sbi	0x05, 0	; 5
 47c:	08 95       	ret

0000047e <directionB.part.1>:
	}
	else if (dir == 3)
	{
		//Forward
		//ONE_B High ONE_A Low
		MOTOR_B_1_PORT &= ~(1 << MOTOR_B_1);
 47e:	5c 98       	cbi	0x0b, 4	; 11
		MOTOR_B_2_PORT |= (1 << MOTOR_B_2);
 480:	5b 9a       	sbi	0x0b, 3	; 11
 482:	08 95       	ret

00000484 <initMotorAB>:
#include "cMotor.h"

void initMotorAB(void)
{
	//Set Data Direction Registers
	MOTOR_A_EN_DDR |= (1 << MOTOR_A_EN);
 484:	56 9a       	sbi	0x0a, 6	; 10
	MOTOR_A_1_DDR |= (1 << MOTOR_A_1);
 486:	57 9a       	sbi	0x0a, 7	; 10
	MOTOR_A_2_DDR |= (1 << MOTOR_A_2);
 488:	20 9a       	sbi	0x04, 0	; 4
	
	MOTOR_B_EN_DDR |= (1 << MOTOR_B_EN);
 48a:	55 9a       	sbi	0x0a, 5	; 10
	MOTOR_B_1_DDR |= (1 << MOTOR_B_1);
 48c:	54 9a       	sbi	0x0a, 4	; 10
	MOTOR_B_2_DDR |= (1 << MOTOR_B_2);
 48e:	53 9a       	sbi	0x0a, 3	; 10
	
	//Set Timer0	
	//Fast PWM - Non-Inverting - Timer clock prescaling by 8
	TCCR0A |= (1 << COM0A1) | (1 << COM0B1); 
 490:	84 b5       	in	r24, 0x24	; 36
 492:	80 6a       	ori	r24, 0xA0	; 160
 494:	84 bd       	out	0x24, r24	; 36
	TCCR0A |= (1 << WGM00) | (1 << WGM01);
 496:	84 b5       	in	r24, 0x24	; 36
 498:	83 60       	ori	r24, 0x03	; 3
 49a:	84 bd       	out	0x24, r24	; 36
	TCCR0B |= (1 << CS01);
 49c:	85 b5       	in	r24, 0x25	; 37
 49e:	82 60       	ori	r24, 0x02	; 2
 4a0:	85 bd       	out	0x25, r24	; 37
 4a2:	08 95       	ret

000004a4 <directionA>:
	OCR0B = speed;
}

void directionA(uint8_t dir)
{
	if(dir ==1)
 4a4:	81 30       	cpi	r24, 0x01	; 1
 4a6:	11 f4       	brne	.+4      	; 0x4ac <directionA+0x8>
	{
		//Both Low
		MOTOR_A_1_PORT &= ~(1 << MOTOR_A_1);
 4a8:	5f 98       	cbi	0x0b, 7	; 11
 4aa:	03 c0       	rjmp	.+6      	; 0x4b2 <directionA+0xe>
		MOTOR_A_2_PORT &= ~(1 << MOTOR_A_2);
	}
	else if(dir ==2)
 4ac:	82 30       	cpi	r24, 0x02	; 2
 4ae:	19 f4       	brne	.+6      	; 0x4b6 <directionA+0x12>
	{
		//ONE_A High ONE_B Low
		MOTOR_A_1_PORT |= (1 << MOTOR_A_1);
 4b0:	5f 9a       	sbi	0x0b, 7	; 11
		MOTOR_A_2_PORT &= ~(1 << MOTOR_A_2);
 4b2:	28 98       	cbi	0x05, 0	; 5
 4b4:	08 95       	ret
	}
	else if (dir == 3)
 4b6:	83 30       	cpi	r24, 0x03	; 3
 4b8:	09 f4       	brne	.+2      	; 0x4bc <directionA+0x18>
 4ba:	de cf       	rjmp	.-68     	; 0x478 <directionA.part.0>
 4bc:	84 30       	cpi	r24, 0x04	; 4
	{
		//ONE_B High ONE_A Low
		MOTOR_A_1_PORT &= ~(1 << MOTOR_A_1);
		MOTOR_A_2_PORT |= (1 << MOTOR_A_2);
	}
	else if (dir==4)
 4be:	11 f4       	brne	.+4      	; 0x4c4 <directionA+0x20>
 4c0:	5f 9a       	sbi	0x0b, 7	; 11
	{
		//Both High
		//Both Low
		MOTOR_A_1_PORT |= (1 << MOTOR_A_1);
 4c2:	28 9a       	sbi	0x05, 0	; 5
		MOTOR_A_2_PORT |= (1 << MOTOR_A_2);
 4c4:	08 95       	ret

000004c6 <directionB>:
	}
}

void directionB(uint8_t dir)
{
	if(dir ==1)
 4c6:	81 30       	cpi	r24, 0x01	; 1
 4c8:	11 f4       	brne	.+4      	; 0x4ce <directionB+0x8>
	{
		//Coast
		//Both Low
		MOTOR_B_1_PORT &= ~(1 << MOTOR_B_1);
 4ca:	5c 98       	cbi	0x0b, 4	; 11
 4cc:	03 c0       	rjmp	.+6      	; 0x4d4 <directionB+0xe>
		MOTOR_B_2_PORT &= ~(1 << MOTOR_B_2);
	}
	else if(dir ==2)
 4ce:	82 30       	cpi	r24, 0x02	; 2
 4d0:	19 f4       	brne	.+6      	; 0x4d8 <directionB+0x12>
	{
		//Backward
		//ONE_A High ONE_B Low
		MOTOR_B_1_PORT |= (1 << MOTOR_B_1);
 4d2:	5c 9a       	sbi	0x0b, 4	; 11
		MOTOR_B_2_PORT &= ~(1 << MOTOR_B_2);
 4d4:	5b 98       	cbi	0x0b, 3	; 11
 4d6:	08 95       	ret
	}
	else if (dir == 3)
 4d8:	83 30       	cpi	r24, 0x03	; 3
 4da:	09 f4       	brne	.+2      	; 0x4de <directionB+0x18>
 4dc:	d0 cf       	rjmp	.-96     	; 0x47e <directionB.part.1>
 4de:	84 30       	cpi	r24, 0x04	; 4
		//Forward
		//ONE_B High ONE_A Low
		MOTOR_B_1_PORT &= ~(1 << MOTOR_B_1);
		MOTOR_B_2_PORT |= (1 << MOTOR_B_2);
	}
	else if (dir==4)
 4e0:	11 f4       	brne	.+4      	; 0x4e6 <directionB+0x20>
 4e2:	5c 9a       	sbi	0x0b, 4	; 11
	{
		//Brake
		//Both High
		MOTOR_B_1_PORT |= (1 << MOTOR_B_1);
 4e4:	5b 9a       	sbi	0x0b, 3	; 11
		MOTOR_B_2_PORT |= (1 << MOTOR_B_2);
 4e6:	08 95       	ret

000004e8 <drive>:
	}
}

void drive(uint8_t command, uint8_t speedA, uint8_t speedB)
{
 4e8:	cf 93       	push	r28
 4ea:	df 93       	push	r29
 4ec:	d6 2f       	mov	r29, r22
 4ee:	c4 2f       	mov	r28, r20
	switch(command)
 4f0:	82 30       	cpi	r24, 0x02	; 2
 4f2:	99 f0       	breq	.+38     	; 0x51a <drive+0x32>
 4f4:	30 f4       	brcc	.+12     	; 0x502 <drive+0x1a>
 4f6:	88 23       	and	r24, r24
 4f8:	61 f0       	breq	.+24     	; 0x512 <drive+0x2a>
 4fa:	81 30       	cpi	r24, 0x01	; 1
 4fc:	e1 f4       	brne	.+56     	; 0x536 <drive+0x4e>
 4fe:	bc df       	rcall	.-136    	; 0x478 <directionA.part.0>
 500:	17 c0       	rjmp	.+46     	; 0x530 <drive+0x48>
 502:	84 30       	cpi	r24, 0x04	; 4
 504:	89 f0       	breq	.+34     	; 0x528 <drive+0x40>
 506:	60 f0       	brcs	.+24     	; 0x520 <drive+0x38>
 508:	85 30       	cpi	r24, 0x05	; 5
 50a:	a9 f4       	brne	.+42     	; 0x536 <drive+0x4e>
 50c:	82 e0       	ldi	r24, 0x02	; 2
			break;
		}
		//PIVOT_LEFT
		case 5:
		{
			directionA(2);
 50e:	ca df       	rcall	.-108    	; 0x4a4 <directionA>
 510:	0f c0       	rjmp	.+30     	; 0x530 <drive+0x48>
 512:	84 e0       	ldi	r24, 0x04	; 4
 514:	c7 df       	rcall	.-114    	; 0x4a4 <directionA>
	switch(command)
	{
		//brake
		case 0:
		{
			directionA(4);
 516:	84 e0       	ldi	r24, 0x04	; 4
 518:	09 c0       	rjmp	.+18     	; 0x52c <drive+0x44>
 51a:	82 e0       	ldi	r24, 0x02	; 2
			directionB(4);
 51c:	c3 df       	rcall	.-122    	; 0x4a4 <directionA>
 51e:	05 c0       	rjmp	.+10     	; 0x52a <drive+0x42>
			break;
		}
		//BACKWARD
		case 2:
		{
			directionA(2);
 520:	81 e0       	ldi	r24, 0x01	; 1
 522:	c0 df       	rcall	.-128    	; 0x4a4 <directionA>
 524:	81 e0       	ldi	r24, 0x01	; 1
 526:	02 c0       	rjmp	.+4      	; 0x52c <drive+0x44>
			break;
		}
		//COAST
		case 3:
		{
			directionA(1);
 528:	a7 df       	rcall	.-178    	; 0x478 <directionA.part.0>
 52a:	82 e0       	ldi	r24, 0x02	; 2
 52c:	cc df       	rcall	.-104    	; 0x4c6 <directionB>
			directionB(1);
 52e:	01 c0       	rjmp	.+2      	; 0x532 <drive+0x4a>
 530:	a6 df       	rcall	.-180    	; 0x47e <directionB.part.1>
 532:	d7 bd       	out	0x27, r29	; 39
 534:	c8 bd       	out	0x28, r28	; 40
		}
		//PIVOT_RIGHT
		case 4:
		{
			directionA(3);
			directionB(2);
 536:	df 91       	pop	r29
 538:	cf 91       	pop	r28
 53a:	08 95       	ret

0000053c <__udivmodhi4>:
 53c:	aa 1b       	sub	r26, r26
 53e:	bb 1b       	sub	r27, r27
 540:	51 e1       	ldi	r21, 0x11	; 17
	TCCR0B |= (1 << CS01);
}

void setSpeedA(uint8_t speed)
{
	OCR0A = speed;
 542:	07 c0       	rjmp	.+14     	; 0x552 <__udivmodhi4_ep>

00000544 <__udivmodhi4_loop>:
}

void setSpeedB(uint8_t speed)
{
	OCR0B = speed;
 544:	aa 1f       	adc	r26, r26
			setSpeedA(speedA);
			setSpeedB(speedB);
			break;
		}
	}
 546:	bb 1f       	adc	r27, r27
 548:	a6 17       	cp	r26, r22
 54a:	b7 07       	cpc	r27, r23
 54c:	10 f0       	brcs	.+4      	; 0x552 <__udivmodhi4_ep>
 54e:	a6 1b       	sub	r26, r22
 550:	b7 0b       	sbc	r27, r23

00000552 <__udivmodhi4_ep>:
 552:	88 1f       	adc	r24, r24
 554:	99 1f       	adc	r25, r25
 556:	5a 95       	dec	r21
 558:	a9 f7       	brne	.-22     	; 0x544 <__udivmodhi4_loop>
 55a:	80 95       	com	r24
 55c:	90 95       	com	r25
 55e:	bc 01       	movw	r22, r24
 560:	cd 01       	movw	r24, r26
 562:	08 95       	ret

00000564 <_exit>:
 564:	f8 94       	cli

00000566 <__stop_program>:
 566:	ff cf       	rjmp	.-2      	; 0x566 <__stop_program>
